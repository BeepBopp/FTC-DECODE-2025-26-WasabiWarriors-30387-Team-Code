package org.firstinspires.ftc.teamcode;

import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import org.firstinspires.ftc.robotcore.external.navigation.Orientation;
import org.firstinspires.ftc.robotcore.external.navigation.AxesReference;
import org.firstinspires.ftc.robotcore.external.navigation.AxesOrder;
import org.firstinspires.ftc.robotcore.external.navigation.AngleUnit;
import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.util.ElapsedTime;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.DcMotorEx;
import com.qualcomm.robotcore.hardware.Servo;
import com.qualcomm.robotcore.hardware.PIDFCoefficients;
import com.qualcomm.hardware.rev.RevHubOrientationOnRobot;
import com.qualcomm.robotcore.hardware.IMU;

@TeleOp(name = "DECODE Teleop")
public class DECODETeleop extends LinearOpMode {

    //
    // Constant parameters to change the robot functions
    // 
    final double DRIVETRAIN_SPEED = 1;                 // Set the speed of the robot (Must be > 0.8) 

    final double LEFT_SHOOTER_VELOCITY = 1650;  //1650;        // Set left shooting motor normal speed
    final double RIGHT_SHOOTER_VELOCITY = 1675; //1675;        // Set right shooting motor normal speed
    final double LEFT_SHOOTER_VELOCITY_HIGH = 2150;     // Set left shooting motor High speed
    final double RIGHT_SHOOTER_VELOCITY_HIGH = 2250;    // Set right shooting motor High speed
    
    final double FEEDER_UP_TIME = 0.6;              // Set feeder up time holding near the shooting motor. (Must be > 0.6)
    final double FEEDER_FOLLOWUP_DURATION = 2.0;    // Set 2nd ball scoop duration after feeder down.
    
    final double TANK_TURN_DURATION = 0.9;  // Set the tank turn duration
    
    final double SPIT_POWER_MULTIPLIER = 0.6;
    
    //
    // Parmeters should not need to change
    //
    final boolean HOLD_TO_RUN_INTAKE = true;    // Enable intake (True = Hold, False = Single Press)
    final boolean AUTO_SCOOP_FWD = true;         // Enable intake moving forward
    final double AUTO_SCOPE_STOP_SPEED = 0.8;    // Max speed auto scooping remains on
    final double LONGEST_SHOOTING_MOTOR_DURATION = 2.0; // Longest time shooting motor can stay on.
    final double SHOOTER_SPOOLUP_TIME = 1;    // Wait time to spool up motor

    final double STOP_POWER = 0;        // Set Intake motor stop power. Always 0.
    final double FEEDER_FOLLOWUP_DELAY = 0.2;        // Set wait time to turn on 2nd ball scoop after feeder down. (Must be > 0.2)    
    final double LEFT_BRINGUP_POS = 0.95;    // Set left feeder up position
    final double RIGHT_BRINGUP_POS = 0.04;  // Set right feeder up position
    final double HALFUP_OFFSET_POS = 0.18;    // Set feeder half way up position (higher number = lower position) 
    final double FULL_POWER = 1.0;  
    final double REST_POS = 0.5;    // Set both left and right feeder position (0.5 is the best)
    
    final double SERVO_FIRE_DELAY = 500;  // Delay for color sensor sequence
    
    //
    // Parameter for hardware state machine 
    //
    private ElapsedTime timerTankTurn = new ElapsedTime();
    private boolean turningLeft = false;
    private boolean turningRight = false;
    
    private ElapsedTime thirdBall = new ElapsedTime();
    private DcMotor leftFrontDrive, rightFrontDrive, leftBackDrive, rightBackDrive, intake;
    private DcMotorEx leftShooter, rightShooter;
    private Servo leftBringUp, rightBringUp;
    
    private IMU imu;

    private ElapsedTime leftFeederTimer = new ElapsedTime();
    private ElapsedTime rightFeederTimer = new ElapsedTime();
    private boolean feedingLeft = false;
    private boolean feedingRight = false;
    private boolean shootingMotorIsOn = false;
    private double feedingStartSecond = 0.0;
    
    private ElapsedTime thirdBallTimer = new ElapsedTime();
    private boolean intakeScoopActive = false;
    private boolean feederUp = false;
    private boolean bringThirdBall = false;
    
    private ElapsedTime pulsatileIntakeTimer = new ElapsedTime();
    private boolean pulsatileIntake = false;
    
    // Color sensor and vision system
    TestBenchHuskyLens vision = new TestBenchHuskyLens();
    TestBenchColor bench = new TestBenchColor();
    
    // Color sensor sequence state
    private ElapsedTime colorSensorTimer = new ElapsedTime();
    private boolean colorSequenceRunning = false;
    private int colorSequenceStep = 0;
    private ColorSequenceType currentColorSequence;
    
    // Enum to define sequence types
    private enum ColorSequenceType {
        BOTH_TOGETHER,      // Fire left and right simultaneously
        LEFT_THEN_RIGHT,    // Fire left, wait, then right
        RIGHT_THEN_LEFT     // Fire right, wait, then left
    }
    
    // Boolean to detect buttons single press
    private boolean lastY = false;
    private boolean lastX = false;
    private boolean lastA = false;
    private boolean lastB = false;
    private boolean lastDTurn = false;
    private boolean lastRightBumper = false;
    private boolean lastLeftBumper = false;
    private boolean lastDDown = false;
    
    private ElapsedTime shootingTimer = new ElapsedTime();

    @Override
    public void runOpMode() {
        //
        // Hardware controls bindings
        //        
        leftFrontDrive = hardwareMap.get(DcMotor.class, "leftFront");
        rightFrontDrive = hardwareMap.get(DcMotor.class, "rightFront");
        leftBackDrive = hardwareMap.get(DcMotor.class, "leftBack");
        rightBackDrive = hardwareMap.get(DcMotor.class, "rightBack");
        leftShooter = hardwareMap.get(DcMotorEx.class, "leftShooter");
        rightShooter = hardwareMap.get(DcMotorEx.class, "rightShooter");
        intake = hardwareMap.get(DcMotor.class, "intake");
        leftBringUp = hardwareMap.get(Servo.class, "leftBringUp");
        rightBringUp = hardwareMap.get(Servo.class, "rightBringUp");
        
        // Initialize color sensor and vision
        bench.init(hardwareMap);
        vision.init(hardwareMap, "huskylens");
        
        IMU imu = hardwareMap.get(IMU.class, "imu");
        RevHubOrientationOnRobot.LogoFacingDirection logoDirection = RevHubOrientationOnRobot.LogoFacingDirection.UP;
        RevHubOrientationOnRobot.UsbFacingDirection  usbDirection  = RevHubOrientationOnRobot.UsbFacingDirection.LEFT;

        RevHubOrientationOnRobot orientationOnRobot = new RevHubOrientationOnRobot(logoDirection, usbDirection);

        // Now initialize the IMU with this mounting orientation
        // Note: if you choose two conflicting directions, this initialization will cause a code exception.
        imu.initialize(new IMU.Parameters(orientationOnRobot));

        leftFrontDrive.setDirection(DcMotor.Direction.REVERSE);
        leftBackDrive.setDirection(DcMotor.Direction.REVERSE);
        intake.setDirection(DcMotor.Direction.FORWARD);
        leftShooter.setDirection(DcMotor.Direction.REVERSE);
        
        leftShooter.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        rightShooter.setMode(DcMotor.RunMode.RUN_USING_ENCODER);

        setBrakeOn();
        //leftShooter.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        //rightShooter.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);

        leftShooter.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, new PIDFCoefficients(300, 0, 0, 10));
        rightShooter.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, new PIDFCoefficients(300, 0, 0, 10));

        waitForStart();

        //
        // Teleops loop starts
        //
        while (opModeIsActive()) {
            
            // Update vision system
            vision.updateMotif();
            
            //
            // Diver gamepad joystick controls 
            // (Left joystick movement, Right joystick turn)
            //            
            
            double y = -gamepad2.left_stick_y;
            double x = gamepad2.left_stick_x;
            double rxRaw = gamepad2.right_stick_x;

            // Reduce turn power when driving forward/strafing to maintain speed
            double driveMag = Math.min(1.0, Math.hypot(x, y));
            double turnScale = 1.0 - 0.3 * driveMag;  // Tune 0.3 lower for less slowdown, higher for more
            double rx = rxRaw * turnScale;

            double denominator = Math.max(Math.abs(y) + Math.abs(x) + Math.abs(rx), 1.0);
            double leftFrontPower  = (y + x + rx) / denominator;
            double leftBackPower   = (y - x + rx) / denominator;
            double rightFrontPower = (y - x - rx) / denominator;
            double rightBackPower  = (y + x - rx) / denominator;

            leftFrontDrive.setPower(leftFrontPower * DRIVETRAIN_SPEED);
            leftBackDrive.setPower(leftBackPower * DRIVETRAIN_SPEED);
            rightFrontDrive.setPower(rightFrontPower * DRIVETRAIN_SPEED);
            rightBackDrive.setPower(rightBackPower * DRIVETRAIN_SPEED);

            ///////////////////////////
            //
            // Tank turn buttons binding  
            //
            ///////////////////////////
            
            // Press arm control dpad left or right to turn
            if (gamepad2.x && !lastDTurn) {
                // Tank turn LEFT
                turningLeft = true;
                timerTankTurn.reset();
            } else if (gamepad2.b && !lastDTurn) {
                // Tank turn RIGHT
                turningRight = true;
                timerTankTurn.reset();
            }
            
            updateTankTurnLeft();
            updateTankTurnRight();
            
            lastDTurn = gamepad2.x || gamepad2.b;  // Catch button hold and release


            //////////////////////////////////
            //
            // Shooter buttons binding
            //
            ///////////////////////////////////

            // COLOR SENSOR SEQUENCE - A button triggers color-based feeding
            if (gamepad1.a && !lastA && !colorSequenceRunning) {
                // Get current colors and motif
                TestBenchColor.DualColorResult colors = bench.getDetectedColors(null);
                int motif = vision.getMotif();
                boolean motifSet = vision.isMotifSet();
                
                // Always run sequence, even if no motif detected (will default to both together)
                determineAndStartColorSequence(motif, colors.left, colors.right);
            }
            
            // Execute color sensor sequence if running
            executeColorSequence();

            // Feeding - Left (X button - now only for manual control)
            if (gamepad1.x && !lastX && !colorSequenceRunning) {
                // Press X to raise left feeder
                feedingLeft = true;
                leftFeederTimer.reset();
                
                if(!shootingMotorIsOn) { // Turn on shooter and wait if not on
                    turnShooterOn();
                    feedingStartSecond = leftFeederTimer.seconds() + SHOOTER_SPOOLUP_TIME;
                }
                else {
                    feedingStartSecond = leftFeederTimer.seconds();
                }
            }

            // Feeding - Right (B button - now only for manual control)
            if (gamepad1.b && !lastB && !colorSequenceRunning) {
                // Press B to raise right feeder
                feedingRight = true;
                rightFeederTimer.reset();
                
                if(!shootingMotorIsOn) { // Turn on shooter and wait if not on
                    turnShooterOn();
                    feedingStartSecond = rightFeederTimer.seconds() + SHOOTER_SPOOLUP_TIME;
                }
                else {
                    feedingStartSecond = rightFeederTimer.seconds();
                }
            }
            
            // Catch button hold and release
            lastX = gamepad1.x;
            lastB = gamepad1.b;
            lastA = gamepad1.a;
            
            updateFeedLeft();
            updateFeedRight();

            // Shooting motor controls
            if (gamepad1.y && !lastY) {
                // Press Y to cycle shooting motor On and Off
                if (!shootingMotorIsOn) {
                    turnShooterOn();
                } else {
                    turnShooterOff();
                }
            }
            lastY = gamepad1.y; // Catch button hold and release

            // Holding dpad UP to increase shooting power
            if (gamepad1.dpad_up && shootingMotorIsOn) {
                // Set shooting motor power to high
                leftShooter.setVelocity(LEFT_SHOOTER_VELOCITY_HIGH);
                rightShooter.setVelocity(RIGHT_SHOOTER_VELOCITY_HIGH);
            }
            else if (!gamepad1.dpad_up && shootingMotorIsOn) {
                // Set shooting motor power to normal
                leftShooter.setVelocity(LEFT_SHOOTER_VELOCITY);
                rightShooter.setVelocity(RIGHT_SHOOTER_VELOCITY);
            }

            //
            // Raise feeer to unstuck the balls
            // 
            if (gamepad1.dpad_down && !lastDDown) {
                feederUp = !feederUp;  // cycle feedup Up and Down states

                if (feederUp) {
                    rightBringUp.setPosition(RIGHT_BRINGUP_POS);
                    leftBringUp.setPosition(LEFT_BRINGUP_POS);
                } else {
                    rightBringUp.setPosition(REST_POS);
                    leftBringUp.setPosition(REST_POS);
                }
            }
            
            lastDDown = gamepad1.dpad_down;

            //////////////////////////////
            //
            // Button press to enable Intake Functions
            //
            /////////////////////////////
            if(HOLD_TO_RUN_INTAKE) // Selecting mode to enable Intake 
            {
                if (gamepad1.left_trigger > 0.1) {
                    // Hold bumper to turn on intake
                    turnIntakeToScoop();
                }
                else if (gamepad1.right_bumper) {
                    // Hold trigger to spit
                    turnIntakeToSpit();
                }
                else {
                    // Intake off
                    intake.setPower(STOP_POWER);
                }
            }
            
            if (gamepad1.right_trigger > 0.1) {
                bringThirdBall = true;
                thirdBallTimer.reset();
            }
            
            bringThirdBall();
            
            if (gamepad1.left_bumper) {
                if (!pulsatileIntake) {
                    pulsatileIntake = true;
                    pulsatileIntakeTimer.reset();
                }
                pulsatileIntake();  
            } else {
                if (pulsatileIntake) {
                    pulsatileIntake = false;
                    intake.setPower(STOP_POWER);
                }
            }
            
            lastRightBumper = gamepad1.right_bumper;
            lastLeftBumper = gamepad1.left_bumper;
            
            // Stop shooting motor if it ran too long
            if (shootingMotorIsOn) {
                if (shootingTimer.seconds() > LONGEST_SHOOTING_MOTOR_DURATION) {
                    if(!feedingLeft && !feedingRight && !colorSequenceRunning) {
                        turnShooterOff(); // stop motors if running more than 10 seconds
                    }
                    else {
                        shootingTimer.reset();
                    }
                }
            }

            // Add color sensor telemetry
            TestBenchColor.DualColorResult currentColors = bench.getDetectedColors(telemetry);
            telemetry.addData("Color Sequence Running", colorSequenceRunning);
            if (colorSequenceRunning) {
                telemetry.addData("Current Sequence", currentColorSequence);
                telemetry.addData("Sequence Step", colorSequenceStep);
            }
            int motif = vision.getMotif();
            if (motif == 0) {
                telemetry.addData("Motif", "0: Green Purple Purple");
            } else if (motif == 1) {
                telemetry.addData("Motif", "1: Purple Green Purple");
            } else if (motif == 2) {
                telemetry.addData("Motif", "2: Purple Purple Green");
            } else {
                telemetry.addData("Motif", "No Motif Detected");
            }
            
            telemetry.update();
        }
    } 
    
////////////////////// Teleops Loop Ends //////////////////////////////

    /////////////////////////////////////////
    // COLOR SENSOR SEQUENCE METHODS
    /////////////////////////////////////////
    
    // Determine which sequence to run based on motif and colors
    private void determineAndStartColorSequence(int motif, TestBenchColor.DetectedColor leftColor,
                                               TestBenchColor.DetectedColor rightColor) {
        // Turn on shooter if not already on
        if (!shootingMotorIsOn) {
            turnShooterOn();
            // Start at -1 to wait for spool up
            colorSequenceStep = -1;
        } else {
            // Shooter already on, skip wait phase
            colorSequenceStep = 0;
        }
        
        // Motif 0: Green Purple Purple - Fire based on which side has green
        if (motif == 0 && leftColor != TestBenchColor.DetectedColor.UNKNOWN &&
                rightColor != TestBenchColor.DetectedColor.UNKNOWN) {
            if (leftColor == TestBenchColor.DetectedColor.GREEN) {
                currentColorSequence = ColorSequenceType.LEFT_THEN_RIGHT;
            } else {
                currentColorSequence = ColorSequenceType.RIGHT_THEN_LEFT;
            }
            colorSequenceRunning = true;
            colorSensorTimer.reset();
        }

        // Motif 1: Purple Green Purple - Fire based on which side has purple
        else if (motif == 1 && leftColor != TestBenchColor.DetectedColor.UNKNOWN &&
                rightColor != TestBenchColor.DetectedColor.UNKNOWN) {
            if (leftColor == TestBenchColor.DetectedColor.PURPLE) {
                currentColorSequence = ColorSequenceType.LEFT_THEN_RIGHT;
            } else {
                currentColorSequence = ColorSequenceType.RIGHT_THEN_LEFT;
            }
            colorSequenceRunning = true;
            colorSensorTimer.reset();
        }

        // Motif 2, no motif detected, unknown colors, or same colors - Fire both together
        else {
            currentColorSequence = ColorSequenceType.BOTH_TOGETHER;
            colorSequenceRunning = true;
            colorSensorTimer.reset();
        }
    }
    
    // Execute the current color sensor sequence
    private void executeColorSequence() {
        if (!colorSequenceRunning) return;

        switch (currentColorSequence) {
            case BOTH_TOGETHER:
                executeColorBothTogether();
                break;

            case LEFT_THEN_RIGHT:
                executeColorLeftThenRight();
                break;

            case RIGHT_THEN_LEFT:
                executeColorRightThenLeft();
                break;
        }
    }
    
    // Fire both servos simultaneously
    private void executeColorBothTogether() {
        // Step -1: Wait for shooter to spool up
        if (colorSequenceStep == -1) {
            if (colorSensorTimer.seconds() >= SHOOTER_SPOOLUP_TIME) {
                colorSequenceStep = 0;
                colorSensorTimer.reset();
            }
        }
        // Step 0: Fire both feeders
        else if (colorSequenceStep == 0) {
            leftBringUp.setPosition(LEFT_BRINGUP_POS);
            rightBringUp.setPosition(RIGHT_BRINGUP_POS);
            colorSequenceStep = 1;
            colorSensorTimer.reset();
        } 
        // Step 1: Wait, then lower feeders and start third ball
        else if (colorSequenceStep == 1 && colorSensorTimer.milliseconds() >= SERVO_FIRE_DELAY) {
            leftBringUp.setPosition(REST_POS);
            rightBringUp.setPosition(REST_POS);
            bringThirdBall = true;
            thirdBallTimer.reset();
            colorSequenceRunning = false;
            colorSequenceStep = 0;
        }
    }
    
    // Fire left first, then right (sequential)
    private void executeColorLeftThenRight() {
        // Step -1: Wait for shooter to spool up
        if (colorSequenceStep == -1) {
            if (colorSensorTimer.seconds() >= SHOOTER_SPOOLUP_TIME) {
                colorSequenceStep = 0;
                colorSensorTimer.reset();
            }
        }
        // Step 0: Fire left feeder
        else if (colorSequenceStep == 0) {
            leftBringUp.setPosition(LEFT_BRINGUP_POS);
            colorSequenceStep = 1;
            colorSensorTimer.reset();
        } 
        // Step 1: Wait, then lower left and fire right
        else if (colorSequenceStep == 1 && colorSensorTimer.milliseconds() >= SERVO_FIRE_DELAY) {
            leftBringUp.setPosition(REST_POS);
            rightBringUp.setPosition(RIGHT_BRINGUP_POS);
            colorSequenceStep = 2;
            colorSensorTimer.reset();
        } 
        // Step 2: Wait, then lower right and start third ball
        else if (colorSequenceStep == 2 && colorSensorTimer.milliseconds() >= SERVO_FIRE_DELAY) {
            rightBringUp.setPosition(REST_POS);
            bringThirdBall = true;
            thirdBallTimer.reset();
            colorSequenceRunning = false;
            colorSequenceStep = 0;
        }
    }
    
    // Fire right first, then left (sequential)
    private void executeColorRightThenLeft() {
        // Step -1: Wait for shooter to spool up
        if (colorSequenceStep == -1) {
            if (colorSensorTimer.seconds() >= SHOOTER_SPOOLUP_TIME) {
                colorSequenceStep = 0;
                colorSensorTimer.reset();
            }
        }
        // Step 0: Fire right feeder
        else if (colorSequenceStep == 0) {
            rightBringUp.setPosition(RIGHT_BRINGUP_POS);
            colorSequenceStep = 1;
            colorSensorTimer.reset();
        } 
        // Step 1: Wait, then lower right and fire left
        else if (colorSequenceStep == 1 && colorSensorTimer.milliseconds() >= SERVO_FIRE_DELAY) {
            rightBringUp.setPosition(REST_POS);
            leftBringUp.setPosition(LEFT_BRINGUP_POS);
            colorSequenceStep = 2;
            colorSensorTimer.reset();
        } 
        // Step 2: Wait, then lower left and start third ball
        else if (colorSequenceStep == 2 && colorSensorTimer.milliseconds() >= SERVO_FIRE_DELAY) {
            leftBringUp.setPosition(REST_POS);
            bringThirdBall = true;
            thirdBallTimer.reset();
            colorSequenceRunning = false;
            colorSequenceStep = 0;
        }
    }

    ////////////////////////////////////////////
    // Tank turn left method
    //////////////////////////////////////////
    private void updateTankTurnLeft() {
        if (!turningLeft) return;
        
        double t = timerTankTurn.seconds();
        
         if (t < TANK_TURN_DURATION) {
            setBrakeOff();
             
            // Turn drivetrain motors for the set duration
            leftFrontDrive.setPower(-FULL_POWER);
            leftBackDrive.setPower(-FULL_POWER);
            rightFrontDrive.setPower(FULL_POWER);
            rightBackDrive.setPower(FULL_POWER);
        } else {
            // Stop motor after duration ended
            leftFrontDrive.setPower(STOP_POWER);
            leftBackDrive.setPower(STOP_POWER);
            rightFrontDrive.setPower(STOP_POWER);
            rightBackDrive.setPower(STOP_POWER);
            
            setBrakeOn();
        
            turningLeft = false;
         }
    }

    ////////////////////////////////////////////
    // Tank turn right method
    //////////////////////////////////////////
    private void updateTankTurnRight() {
        if (!turningRight) return;
        
        double t = timerTankTurn.seconds();
        
         if (t < TANK_TURN_DURATION) {
            setBrakeOff();
             
            // Turn drivetrain motors for the set duration
            leftFrontDrive.setPower(FULL_POWER);
            leftBackDrive.setPower(FULL_POWER);
            rightFrontDrive.setPower(-FULL_POWER);
            rightBackDrive.setPower(-FULL_POWER);
         }
         else {
            setBrakeOn();
            
            // Stop motor after duration ended
            leftFrontDrive.setPower(STOP_POWER);
            leftBackDrive.setPower(STOP_POWER);
            rightFrontDrive.setPower(STOP_POWER);
            rightBackDrive.setPower(STOP_POWER);
            turningRight = false;
         }
    }

    /////////////////////////
    // Scooping in balls method
    /////////////////////////////
    private void turnIntakeToScoop() {
        
        if(feedingLeft || feedingRight || colorSequenceRunning) // Do not turn on intake while feeding
            return;
        
        // Turn on intake motor to in direction
        intake.setDirection(DcMotor.Direction.FORWARD);
        intake.setPower(2.0);
    }

    //////////////////////////
    // Spitting out balls method
    ///////////////////////////
    private void turnIntakeToSpit() {
        // Turn on intake motor to out direction
        intake.setDirection(DcMotor.Direction.REVERSE);
        intake.setPower(FULL_POWER * SPIT_POWER_MULTIPLIER);
    }

    ///////////////////////////////////
    // Turn on shooting motor
    ///////////////////////////////////
    private void turnShooterOn() {
        leftShooter.setVelocity(LEFT_SHOOTER_VELOCITY);
        rightShooter.setVelocity(RIGHT_SHOOTER_VELOCITY);
        shootingMotorIsOn = true;
        shootingTimer.reset(); // start timing when shooter turns on
    }

    ////////////////////////////////
    // Turn off shooting motor
    ////////////////////////////////
    private void turnShooterOff() {
        leftShooter.setVelocity(STOP_POWER);
        rightShooter.setVelocity(STOP_POWER);
        shootingMotorIsOn = false;
        shootingTimer.reset(); // reset timer when shooter turns off
    }

    ///////////////////////////////
    // Method to move left feeder up
    //////////////////////////////
    private void updateFeedLeft() {
        if (!feedingLeft || colorSequenceRunning) return;

        double t = leftFeederTimer.seconds();

        if (t > feedingStartSecond && t < (FEEDER_UP_TIME + feedingStartSecond)) {  // Feeding ball
            intake.setPower(STOP_POWER);
            leftBringUp.setPosition(LEFT_BRINGUP_POS);
        } else if (t > feedingStartSecond && t < (FEEDER_UP_TIME + FEEDER_FOLLOWUP_DELAY + feedingStartSecond)) { // lower the arms
            leftBringUp.setPosition(REST_POS);
        } else if (t > feedingStartSecond && t < (FEEDER_UP_TIME + 0.5 + feedingStartSecond)) { // extra scope after arm is down
            intake.setDirection(DcMotor.Direction.REVERSE);
            intake.setPower(FULL_POWER/2);
        } else if (t > feedingStartSecond && t < (FEEDER_UP_TIME + FEEDER_FOLLOWUP_DURATION + 0.5 + feedingStartSecond) && !feedingRight) { // extra scope after arm is down
            intake.setDirection(DcMotor.Direction.FORWARD);
            intake.setPower(FULL_POWER);
        } else if (t > feedingStartSecond) { // Feeding completed
            intake.setPower(STOP_POWER);
            feedingLeft = false;
            feedingStartSecond = 0.0;
        }
    }

    ///////////////////////////////
    // Method to move right feeder up
    //////////////////////////////
    private void updateFeedRight() {
        if (!feedingRight || colorSequenceRunning) return;

        double t = rightFeederTimer.seconds();
        
        if (t > feedingStartSecond && t < (FEEDER_UP_TIME + feedingStartSecond)) { // Feeding ball
            intake.setPower(STOP_POWER);
            rightBringUp.setPosition(RIGHT_BRINGUP_POS);
        } else if (t > feedingStartSecond && t < (FEEDER_UP_TIME + FEEDER_FOLLOWUP_DELAY + feedingStartSecond)) { // lower the arms
            rightBringUp.setPosition(REST_POS);
        } else if (t > feedingStartSecond && t < (FEEDER_UP_TIME + 0.5 + feedingStartSecond)) { // extra scope after feeder down
            intake.setDirection(DcMotor.Direction.REVERSE);
            intake.setPower(FULL_POWER / 2); 
        } else if (t > feedingStartSecond && t < (FEEDER_UP_TIME + FEEDER_FOLLOWUP_DURATION + 0.5 + feedingStartSecond) && !feedingLeft) { // extra scope after feeder down
            intake.setDirection(DcMotor.Direction.FORWARD);
            intake.setPower(FULL_POWER);
        } else if (t > feedingStartSecond) { // Feeding completed
            intake.setPower(STOP_POWER);
            feedingRight = false;
            feedingStartSecond = 0.0;
        }
    }

    private void bringThirdBall() {
        if (!bringThirdBall) return;
        
        double t = thirdBallTimer.seconds();
        
        if (t > 0 && t < 0.2) {
            intake.setPower(STOP_POWER);
        } else if (t > 0.2 && t < 0.5) {
            intake.setDirection(DcMotor.Direction.REVERSE);
            intake.setPower(FULL_POWER/2);
        } else if (t > 0.5 && t < 1) {
            intake.setDirection(DcMotor.Direction.FORWARD);
            intake.setPower(0.9);
        } else if (t > 1) {
            intake.setPower(STOP_POWER);
            bringThirdBall = false;
        }
    }
    
    private void pulsatileIntake() {
        if (!pulsatileIntake) return;
        
        double t = pulsatileIntakeTimer.seconds();
        
        // Cycle: 0.5s ON, 1.0s OFF, repeat
        double cycleTime = t % 1.5;  // Total cycle is 1.5 seconds
        
        if (cycleTime < 0.5) {
            // First 0.5 seconds: intake ON
            intake.setDirection(DcMotor.Direction.FORWARD);
            intake.setPower(FULL_POWER);
        } else {
            // Next 1.0 seconds: intake OFF (pause)
            intake.setPower(STOP_POWER);
        }
    }
    
    private void setBrakeOn() {
        // Set FLOAT before powering for smooth turns
        leftFrontDrive.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        leftBackDrive.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        rightFrontDrive.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        rightBackDrive.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
    }
    
    private void setBrakeOff() {
        // Set FLOAT before powering for smooth turns
        leftFrontDrive.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.FLOAT);
        leftBackDrive.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.FLOAT);
        rightFrontDrive.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.FLOAT);
        rightBackDrive.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.FLOAT);
    }
}
